/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const DcElementResult_Err: DcElementResult = 0;
pub const DcElementResult_Close: DcElementResult = 1;
pub const DcElementResult_Msg: DcElementResult = 2;
pub const DcElementResult_MsgBuf: DcElementResult = 3;
#[doc = " Element result"]
pub type DcElementResult = ::core::ffi::c_uint;
pub const DcLogLevel_Error: DcLogLevel = 0;
pub const DcLogLevel_Warn: DcLogLevel = 1;
pub const DcLogLevel_Info: DcLogLevel = 2;
pub const DcLogLevel_Debug: DcLogLevel = 3;
pub const DcLogLevel_Trace: DcLogLevel = 4;
pub type DcLogLevel = u8;
pub const DcMetadataType_Empty: DcMetadataType = 0;
pub const DcMetadataType_Int64: DcMetadataType = 1;
pub const DcMetadataType_Float64: DcMetadataType = 2;
pub const DcMetadataType_Duration: DcMetadataType = 3;
pub type DcMetadataType = u8;
pub type DcMetadataId = u32;
#[doc = " Reference counted message."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DcMsg {
//     pub _ptr: *mut ::core::ffi::c_void,
    pub _ptr: ::core::ptr::NonNull<::core::ffi::c_void>,
    pub _size: usize,
}
#[test]
fn bindgen_test_layout_DcMsg() {
    const UNINIT: ::core::mem::MaybeUninit<DcMsg> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DcMsg>(),
        16usize,
        concat!("Size of: ", stringify!(DcMsg))
    );
    assert_eq!(
        ::core::mem::align_of::<DcMsg>(),
        8usize,
        concat!("Alignment of ", stringify!(DcMsg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DcMsg),
            "::",
            stringify!(_ptr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DcMsg),
            "::",
            stringify!(_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DcDuration {
    pub secs: u64,
    pub nsecs: u32,
}
#[test]
fn bindgen_test_layout_DcDuration() {
    const UNINIT: ::core::mem::MaybeUninit<DcDuration> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DcDuration>(),
        16usize,
        concat!("Size of: ", stringify!(DcDuration))
    );
    assert_eq!(
        ::core::mem::align_of::<DcDuration>(),
        8usize,
        concat!("Alignment of ", stringify!(DcDuration))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).secs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DcDuration),
            "::",
            stringify!(secs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nsecs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DcDuration),
            "::",
            stringify!(nsecs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DcMetadataValue {
    pub int64: i64,
    pub float64: f64,
    pub duration: DcDuration,
}
#[test]
fn bindgen_test_layout_DcMetadataValue() {
    const UNINIT: ::core::mem::MaybeUninit<DcMetadataValue> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DcMetadataValue>(),
        16usize,
        concat!("Size of: ", stringify!(DcMetadataValue))
    );
    assert_eq!(
        ::core::mem::align_of::<DcMetadataValue>(),
        8usize,
        concat!("Alignment of ", stringify!(DcMetadataValue))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).int64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DcMetadataValue),
            "::",
            stringify!(int64)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).float64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DcMetadataValue),
            "::",
            stringify!(float64)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).duration) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DcMetadataValue),
            "::",
            stringify!(duration)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DcMetadata {
    pub id: DcMetadataId,
    pub type_: DcMetadataType,
    pub value: DcMetadataValue,
}
#[test]
fn bindgen_test_layout_DcMetadata() {
    const UNINIT: ::core::mem::MaybeUninit<DcMetadata> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DcMetadata>(),
        24usize,
        concat!("Size of: ", stringify!(DcMetadata))
    );
    assert_eq!(
        ::core::mem::align_of::<DcMetadata>(),
        8usize,
        concat!("Alignment of ", stringify!(DcMetadata))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DcMetadata),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DcMetadata),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DcMetadata),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DcMsgBuf {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DcMsgReceiver {
    _unused: [u8; 0],
}
#[doc = " Port number"]
pub type DcPort = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DcPipeline {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DcPlugin {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DcElement {
    _unused: [u8; 0],
}
pub type DcElementNewFunc = ::core::option::Option<
    unsafe extern "C-unwind" fn(config: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_void,
>;
pub type DcElementNextFunc = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        element: *mut ::core::ffi::c_void,
        arg1: *mut DcPipeline,
        arg2: *mut DcMsgReceiver,
    ) -> DcElementResult,
>;
pub type DcElementFreeFunc =
    ::core::option::Option<unsafe extern "C-unwind" fn(element: *mut ::core::ffi::c_void)>;
pub type DcFinalizerFunc =
    ::core::option::Option<unsafe extern "C-unwind" fn(arg1: *mut ::core::ffi::c_void) -> bool>;
#[doc = " Finalizer for element"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DcFinalizer {
    pub f: DcFinalizerFunc,
    pub context: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_DcFinalizer() {
    const UNINIT: ::core::mem::MaybeUninit<DcFinalizer> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DcFinalizer>(),
        16usize,
        concat!("Size of: ", stringify!(DcFinalizer))
    );
    assert_eq!(
        ::core::mem::align_of::<DcFinalizer>(),
        8usize,
        concat!("Alignment of ", stringify!(DcFinalizer))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DcFinalizer),
            "::",
            stringify!(f)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DcFinalizer),
            "::",
            stringify!(context)
        )
    );
}
pub type DcElementFinalizerCreatorFunc = ::core::option::Option<
    unsafe extern "C-unwind" fn(
        element: *mut ::core::ffi::c_void,
        finalizer: *mut DcFinalizer,
    ) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DcRunner {
    _unused: [u8; 0],
}
pub type DcPluginInitFunc =
    ::core::option::Option<unsafe extern "C-unwind" fn(dc_plugin: *mut DcPlugin) -> bool>;
#[repr(C)]
#[derive(Debug)]
pub struct DcElementInfo {
    pub id: *const ::core::ffi::c_char,
    pub origin: *const ::core::ffi::c_char,
    pub authors: *const ::core::ffi::c_char,
    pub description: *const ::core::ffi::c_char,
    pub config_doc: *const ::core::ffi::c_char,
    pub recv_ports: DcPort,
    pub send_ports: DcPort,
    pub recv_msg_types: *const *const *const ::core::ffi::c_char,
    pub send_msg_types: *const *const *const ::core::ffi::c_char,
    pub metadata_ids: *const *const ::core::ffi::c_char,
    pub _extension_fields: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_DcElementInfo() {
    const UNINIT: ::core::mem::MaybeUninit<DcElementInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DcElementInfo>(),
        72usize,
        concat!("Size of: ", stringify!(DcElementInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<DcElementInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(DcElementInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DcElementInfo),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).origin) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DcElementInfo),
            "::",
            stringify!(origin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).authors) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DcElementInfo),
            "::",
            stringify!(authors)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DcElementInfo),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).config_doc) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(DcElementInfo),
            "::",
            stringify!(config_doc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).recv_ports) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(DcElementInfo),
            "::",
            stringify!(recv_ports)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_ports) as usize - ptr as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(DcElementInfo),
            "::",
            stringify!(send_ports)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).recv_msg_types) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(DcElementInfo),
            "::",
            stringify!(recv_msg_types)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_msg_types) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(DcElementInfo),
            "::",
            stringify!(send_msg_types)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).metadata_ids) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(DcElementInfo),
            "::",
            stringify!(metadata_ids)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._extension_fields) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(DcElementInfo),
            "::",
            stringify!(_extension_fields)
        )
    );
}
pub type DcRunnerIterElementsFunc = ::core::option::Option<
    unsafe extern "C-unwind" fn(arg1: *mut ::core::ffi::c_void, arg2: *const DcElementInfo),
>;
extern "C" {
    #[doc = " Initialize logger."]
    pub fn dc_log_init(level: DcLogLevel);
}
extern "C" {
    #[doc = " Get current log level."]
    pub fn dc_log_get_level() -> DcLogLevel;
}
extern "C" {
    #[doc = " Append a log."]
    pub fn dc_log(
        level: DcLogLevel,
        plugin: *const ::core::ffi::c_char,
        module: *const ::core::ffi::c_char,
        msg: *const ::core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " Get a metadata id from given string.\n Return zero if given string is invalid or unknown. If this function is called from out of task threads, returns zero also."]
    pub fn dc_metadata_get_id(string_id: *const ::core::ffi::c_char) -> DcMetadataId;
}
extern "C" {
    #[doc = " Clone a DcMsg. Increases the reference counter."]
    pub fn dc_msg_clone(msg: *const DcMsg) -> DcMsg;
}
extern "C" {
    #[doc = " Free a DcMsg. Decrease the reference counter."]
    pub fn dc_msg_free(msg: DcMsg);
}
extern "C" {
    #[doc = " Get data from a message."]
    pub fn dc_msg_get_data(msg: *const DcMsg, data: *mut *const u8, len: *mut usize);
}
extern "C" {
    #[doc = " Get metadata from a message."]
    pub fn dc_msg_get_metadata(msg: *const DcMsg, id: DcMetadataId) -> DcMetadata;
}
extern "C" {
    #[doc = " Set metadata to a message."]
    pub fn dc_msg_set_metadata(msg: *mut DcMsg, metadata: DcMetadata);
}
extern "C" {
    #[doc = " Create a message buffer."]
    pub fn dc_msg_buf_new() -> *mut DcMsgBuf;
}
extern "C" {
    #[doc = " Write data to a message buffer."]
    pub fn dc_msg_buf_write(msg_buf: *mut DcMsgBuf, data: *const u8, len: usize);
}
extern "C" {
    #[doc = " Set metadata to a message buffer."]
    pub fn dc_msg_buf_set_metadata(msg_buf: *mut DcMsgBuf, metadata: DcMetadata);
}
extern "C" {
    #[doc = " Take message from a message buffer. Clears the buffer."]
    pub fn dc_msg_buf_take_msg(msg_buf: *mut DcMsgBuf) -> DcMsg;
}
extern "C" {
    #[doc = " Get the current bytes length of this buffer."]
    pub fn dc_msg_buf_get_len(msg_buf: *const DcMsgBuf) -> usize;
}
extern "C" {
    #[doc = " Free a message buffer."]
    pub fn dc_msg_buf_free(msg_buf: *mut DcMsgBuf);
}
extern "C" {
    #[doc = " Receive a message from specified port. Return false if sender task closed or an error occured."]
    pub fn dc_msg_receiver_recv(
        msg_receiver: *mut DcMsgReceiver,
        port: DcPort,
        msg: *mut DcMsg,
    ) -> bool;
}
extern "C" {
    #[doc = " Receive a message. Return false if sender task closed or an error occured."]
    pub fn dc_msg_receiver_recv_any_port(
        msg_receiver: *mut DcMsgReceiver,
        port: *mut DcPort,
        msg: *mut DcMsg,
    ) -> bool;
}
extern "C" {
    #[doc = " Set an error message."]
    pub fn dc_pipeline_set_err_msg(pipeline: *mut DcPipeline, err_msg: *const ::core::ffi::c_char);
}
extern "C" {
    #[doc = " Set a message as a result in next() function."]
    pub fn dc_pipeline_set_result_msg(pipeline: *mut DcPipeline, port: DcPort, msg: DcMsg);
}
extern "C" {
    #[doc = " Get DcMsgBuf for specified port. MUST NOT specify the port that DcMsgBuf already have been gotten."]
    pub fn dc_pipeline_get_msg_buf(pipeline: *mut DcPipeline, port: DcPort) -> *mut DcMsgBuf;
}
extern "C" {
    #[doc = " Get this execution is closing."]
    pub fn dc_pipeline_get_closing(pipeline: *const DcPipeline) -> bool;
}
extern "C" {
    #[doc = " Set flag that this execution is closing."]
    pub fn dc_pipeline_close(pipeline: *mut DcPipeline);
}
extern "C" {
    #[doc = " Get DcMetadataId from string id. Return zero if given string is invalid or unknown."]
    pub fn dc_pipeline_get_metadata_id(
        pipeline: *const DcPipeline,
        string_id: *const ::core::ffi::c_char,
    ) -> DcMetadataId;
}
extern "C" {
    pub fn dc_plugin_init(dc_plugin: *mut DcPlugin) -> bool;
}
extern "C" {
    #[doc = " Set name to this plugin."]
    pub fn dc_plugin_set_name(plugin: *mut DcPlugin, name: *const ::core::ffi::c_char) -> bool;
}
extern "C" {
    #[doc = " Set framework version to this plugin."]
    pub fn dc_plugin_set_version(
        plugin: *mut DcPlugin,
        version: *const ::core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Register a element to this plugin."]
    pub fn dc_plugin_register_element(plugin: *mut DcPlugin, element: *const DcElement);
}
extern "C" {
    #[doc = " Set authors to this plugin."]
    pub fn dc_plugin_set_authors(
        plugin: *mut DcPlugin,
        authors: *const ::core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Create an element."]
    pub fn dc_element_new(
        name: *const ::core::ffi::c_char,
        recv_ports: DcPort,
        send_ports: DcPort,
        new_: DcElementNewFunc,
        next: DcElementNextFunc,
        free: DcElementFreeFunc,
    ) -> *mut DcElement;
}
extern "C" {
    #[doc = " Set a description to an element."]
    pub fn dc_element_set_description(element: *mut DcElement, desc: *const ::core::ffi::c_char);
}
extern "C" {
    #[doc = " Set a configration document to an element."]
    pub fn dc_element_set_config_doc(
        element: *mut DcElement,
        config_doc: *const ::core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " Set a message type for receiving to an element."]
    pub fn dc_element_append_recv_msg_type(
        element: *mut DcElement,
        port: DcPort,
        msg_type: *const ::core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Set a message type for sending to an element."]
    pub fn dc_element_append_send_msg_type(
        element: *mut DcElement,
        port: DcPort,
        msg_type: *const ::core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Set a metadata id to an element."]
    pub fn dc_element_append_metadata_id(
        element: *mut DcElement,
        metadata_id: *const ::core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Set finalizer creator to an element."]
    pub fn dc_element_set_finalizer_creator(
        element: *mut DcElement,
        f: DcElementFinalizerCreatorFunc,
    );
}
extern "C" {
    #[doc = " Create a runner."]
    pub fn dc_runner_new() -> *mut DcRunner;
}
extern "C" {
    #[doc = " Set configuration to a runner."]
    pub fn dc_runner_set_config(runner: *mut DcRunner, config: *const ::core::ffi::c_char);
}
extern "C" {
    #[doc = " Append a path to directory that includes plugin files."]
    pub fn dc_runner_append_dir(runner: *mut DcRunner, path: *const ::core::ffi::c_char);
}
extern "C" {
    #[doc = " Append a path to a plugin file."]
    pub fn dc_runner_append_file(runner: *mut DcRunner, path: *const ::core::ffi::c_char);
}
extern "C" {
    #[doc = " Append a plugin init function."]
    pub fn dc_runner_append_plugin_init(
        runner: *mut DcRunner,
        name: *const ::core::ffi::c_char,
        f: DcPluginInitFunc,
    );
}
extern "C" {
    #[doc = " Run."]
    pub fn dc_runner_run(runner: *mut DcRunner) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " Iterate elements by callback."]
    pub fn dc_runner_iter_elements(
        runner: *mut DcRunner,
        f: DcRunnerIterElementsFunc,
        p: *mut ::core::ffi::c_void,
    );
}
